{"file_contents":{"handlers/__init__.py":{"content":"","size_bytes":0},"utils/constants.py":{"content":"# utils/constants.py\n\n# --- Conversation States for Admin Panel ---\n(\n    SELECTING_ACTION, GET_NAME, GET_PHOTO, GET_YEAR,\n    GET_CATEGORIES, \n    GET_TIMER, GET_CONTENT_VIDEOS, CONFIRM_DELETE, GET_SERIES_SEASON_COUNT,\n    GET_SERIES_EPISODES, SELECT_RENAME_ITEM, GET_NEW_NAME,\n    # --- NEW Edit Series States ---\n    SELECT_EDIT_SERIES, SELECT_EDIT_SEASON, SELECT_EDIT_ACTION,\n    ADD_SERIES_EPISODES, REMOVE_SERIES_EPISODES,\n) = range(17)\n\n# --- Callback Data Prefixes ---\nCALLBACK_MOVIE_SELECT = \"movie_select_\"\nCALLBACK_SERIES_SELECT = \"series_select_\"\nCALLBACK_SEASON_SELECT = \"season_select_\"\nCALLBACK_YEAR_PAGE = \"year_page_\"\nCALLBACK_YEAR_SELECT = \"year_select_\"\nCALLBACK_YEAR_CONTENT_TYPE = \"year_content_\"\nCALLBACK_DELETE_MOVIE = \"del_movie_\"\nCALLBACK_DELETE_SERIES = \"del_series_\"\nCALLBACK_REGET_MOVIE = \"reget_movie_\"\nCALLBACK_REGET_SERIES = \"reget_series_\"\nCALLBACK_RENAME_MOVIE = \"ren_movie_\"\nCALLBACK_RENAME_SERIES = \"ren_series_\"\nCALLBACK_MOVIE_PAGE = \"movie_page_\"\nCALLBACK_SERIES_PAGE = \"series_page_\"\n\n# --- Category Callbacks ---\nCALLBACK_CATEGORY_PAGE = \"cat_page_\"\nCALLBACK_CATEGORY_SELECT = \"cat_select_\"\nCALLBACK_CATEGORY_CONTENT_TYPE = \"cat_content_\"\n\n# Admin Panel Actions\nCALLBACK_ADMIN_ADD_MOVIE = \"admin_add_movie\"\nCALLBACK_ADMIN_ADD_SERIES = \"admin_add_series\"\nCALLBACK_ADMIN_DELETE_MOVIE = \"admin_delete_movie\"\nCALLBACK_ADMIN_DELETE_SERIES = \"admin_delete_series\"\nCALLBACK_ADMIN_RENAME_MOVIE = \"admin_rename_movie\"\nCALLBACK_ADMIN_RENAME_SERIES = \"admin_rename_series\"\nCALLBACK_ADMIN_EDIT_SERIES = \"admin_edit_series\"\nCALLBACK_ADMIN_CANCEL = \"admin_cancel\"\n\n# --- NEW Edit Series Callbacks ---\nCALLBACK_EDIT_SERIES_PAGE = \"edit_series_page_\"\nCALLBACK_EDIT_SERIES_SELECT = \"edit_series_select_\"\nCALLBACK_EDIT_SEASON_SELECT = \"edit_season_select_\"\nCALLBACK_EDIT_ACTION_ADD = \"edit_action_add\"\nCALLBACK_EDIT_ACTION_REMOVE = \"edit_action_remove\"\nCALLBACK_REMOVE_EPISODE = \"remove_episode_\"\n\n# --- Message Templates & Stickers ---\n# Find a valid File ID by sending a sticker to a bot like @JsonDumpBot\nTHANK_YOU_STICKER_ID = \"CAACAgIAAxkBAAECHLlopW_Gd1s1_YHzl-PJ76xUOYa4NAACNDoAArR2CUgmpTx1tcQieDYE\" # Replace if you have one, or set to None\n\nDELETION_WARNING_TEXT = \"\"\"\n‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è **·Ä°·Äõ·Ä±·Ä∏·ÄÄ·Äº·ÄÆ·Ä∏·Äï·Ä´·Äê·Äö·Ä∫** ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è\n\n·Ä§·Äõ·ÄØ·Äï·Ä∫·Äõ·Äæ·ÄÑ·Ä∫·Äñ·Ä≠·ÄØ·ÄÑ·Ä∫·Äô·Äª·Ä¨·Ä∏/·Äó·ÄÆ·Äí·ÄÆ·Äö·Ä≠·ÄØ·Äô·Äª·Ä¨·Ä∏·ÄÄ·Ä≠·ÄØ   **{timer} ·Äô·Ä≠·Äî·ÄÖ·Ä∫** ·Ä°·Äê·ÄΩ·ÄÑ·Ä∫·Ä∏  (·Äô·Ä∞·Äï·Ä≠·ÄØ·ÄÑ·Ä∫·ÄÅ·ÄΩ·ÄÑ·Ä∑·Ä∫·Äï·Äº·Äø·Äî·Ä¨·Äô·Äª·Ä¨·Ä∏·ÄÄ·Äº·Ä±·Ä¨·ÄÑ·Ä∑·Ä∫) ·Äñ·Äª·ÄÄ·Ä∫·Äï·Ä´·Äô·Ää·Ä∫·Åã\n\n·ÄÄ·Äª·Ä±·Ä∏·Äá·Ä∞·Ä∏·Äï·Äº·ÄØ·Åç ·Ä§·Äñ·Ä≠·ÄØ·ÄÑ·Ä∫·Äô·Äª·Ä¨·Ä∏/·Äó·ÄÆ·Äí·ÄÆ·Äö·Ä≠·ÄØ·Äô·Äª·Ä¨·Ä∏·Ä°·Ä¨·Ä∏·Äú·ÄØ·Ä∂·Ä∏·ÄÄ·Ä≠·ÄØ ·Äû·ÄÑ·Ä∫·Åè Save Messages ·Äû·Ä≠·ÄØ·Ä∑ Forward ·Äú·ÄØ·Äï·Ä∫·Äï·Äº·ÄÆ·Ä∏ ·Äë·Ä≠·ÄØ·Äî·Ä±·Äõ·Ä¨·Äê·ÄΩ·ÄÑ·Ä∫ ·Äá·Ä¨·Äê·Ä∫·ÄÄ·Ä¨·Ä∏·Ä°·Ä¨·Ä∏·ÄÄ·Äº·Ää·Ä∫·Ä∑·Äõ·Äæ·ÄØ·Äï·Ä´·Åã\n\n---\n\n‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è **IMPORTANT** ‚ùóÔ∏èÔ∏è‚ùóÔ∏è‚ùóÔ∏è\n\nThese Movie Files/Videos will be deleted in **{timer} mins** (Due to Copyright Issues).\n\nPlease **forward** ALL Files/Videos to your **Saved Messages** and watch from there.\n\"\"\"","size_bytes":3087},"utils/decorators.py":{"content":"# utils/decorators.py\nimport logging\nfrom functools import wraps\nfrom telegram import Update\nfrom telegram.ext import ContextTypes\nimport config\n\nlogger = logging.getLogger(__name__)\n\n\ndef admin_only(func):\n    @wraps(func)\n    async def wrapped(update: Update, context: ContextTypes.DEFAULT_TYPE, *args, **kwargs):\n        user_id = update.effective_user.id\n        if user_id not in config.ADMIN_IDS:\n            logger.warning(f\"Unauthorized access attempt for admin command by user {user_id}\")\n            return\n        return await func(update, context, *args, **kwargs)\n    return wrapped\n\ndef check_channel_membership(func):\n    # ... (no changes needed here)\n    pass","size_bytes":676},"handlers/user/start.py":{"content":"# handlers/user/start.py\nimport logging\nfrom telegram import Update\nfrom telegram.ext import ContextTypes, CommandHandler\nfrom telegram.constants import ParseMode\nfrom keyboards.reply import main_reply_keyboard\n\n# Import the search functions to be called directly\nfrom .search import search_movie, search_series\n\nlogger = logging.getLogger(__name__)\n\nasync def start(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    \"\"\"\n    Handles the /start command. It now also processes deep links.\n    \"\"\"\n    # --- DEEP LINKING LOGIC ---\n    if context.args:\n        # A deep link was used, e.g., /start mv_Inception\n        payload = context.args[0]\n        \n        if payload.startswith(\"mv_\"):\n            # This is a movie deep link\n            movie_name_encoded = payload.replace(\"mv_\", \"\", 1)\n            # Replace underscores back with spaces for the search\n            movie_name = movie_name_encoded.replace(\"_\", \" \")\n            \n            # We need to manually set the context.args for the search function\n            context.args = movie_name.split()\n            await update.effective_message.reply_text(f\"üé¨ Searching for movie: {movie_name}...\")\n            await search_movie(update, context)\n            return # Stop further execution\n\n        elif payload.startswith(\"sr_\"):\n            # This is a series deep link\n            series_name_encoded = payload.replace(\"sr_\", \"\", 1)\n            series_name = series_name_encoded.replace(\"_\", \" \")\n\n            context.args = series_name.split()\n            await update.effective_message.reply_text(f\"üì∫ Searching for series: {series_name}...\")\n            await search_series(update, context)\n            return # Stop further execution\n\n    # --- REGULAR /start LOGIC ---\n    # If no deep link was found, or if it was an invalid format, show the normal welcome message.\n    await update.effective_message.reply_text(\n        \"üéâ Welcome to the Cineverse Bot!\\n\\n\"\n        \"Use the menu below to find movies and series.\",\n        reply_markup=main_reply_keyboard()\n    )\n\n\nasync def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    \"\"\"Displays detailed help information using correctly escaped MarkdownV2.\"\"\"\n    text = r\"\"\"\nüìñ *Cineverse Bot Help*\n\nHere's how to use the bot:\n\n*Navigation*\nUse the buttons at the bottom of the screen to browse content\\.\n\n*Quick Search Commands*\nüîπ `/mv <name>` \\- Search for a movie\\.\n   *Example: `/mv inception`*\n\nüîπ `/sr <name>` \\- Search for a series\\.\n   *Example: `/sr breaking bad`*\n\nEnjoy free access to all movies and series\\!\n\"\"\"\n    await update.effective_message.reply_text(\n        text,\n        parse_mode=ParseMode.MARKDOWN_V2,\n        reply_markup=main_reply_keyboard()\n    )\n\nstart_handler = CommandHandler(\"start\", start)\nhelp_handler = CommandHandler(\"help\", help_command)","size_bytes":2827},"handlers/user/__init__.py":{"content":"# handlers/user/__init__.py\n\nfrom .start import start_handler, help_handler\nfrom .search import movie_search_handler, series_search_handler, generic_search_handler\nfrom .browsing import browsing_handlers","size_bytes":203},"utils/__init__.py":{"content":"","size_bytes":0},"handlers/user/search.py":{"content":"# handlers/user/search.py\nimport logging\nimport asyncio\nfrom telegram import Update\nfrom telegram.ext import ContextTypes, CommandHandler, MessageHandler, filters\nfrom database import db_handler\nfrom keyboards.inline import movie_list_keyboard, series_list_keyboard\n\nlogger = logging.getLogger(__name__)\n\nasync def search_movie(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    \"\"\"Handles the /mv command to search for movies.\"\"\"\n    query = \" \".join(context.args).lower()\n    if not query:\n        await update.message.reply_text(\"‚ùå Please provide a movie name. Example: `/mv inception`\")\n        return\n\n    all_movies = db_handler.get_all_movies()\n    results = [movie for movie in all_movies if query in movie['name'].lower()]\n\n    if not results:\n        await update.message.reply_text(f\"‚ùå No movies found matching '{query}'.\")\n        return\n\n    await update.message.reply_text(\n        f\"üîé Found {len(results)} movie(s) matching your search:\",\n        reply_markup=movie_list_keyboard(results)\n    )\n\nasync def search_series(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    \"\"\"Handles the /sr command to search for series.\"\"\"\n    query = \" \".join(context.args).lower()\n    if not query:\n        await update.message.reply_text(\"‚ùå Please provide a series name. Example: `/sr game of thrones`\")\n        return\n\n    all_series = db_handler.get_all_series()\n    results = [series for series in all_series if query in series['name'].lower()]\n\n    if not results:\n        await update.message.reply_text(f\"‚ùå No series found matching '{query}'.\")\n        return\n\n    await update.message.reply_text(\n        f\"üîé Found {len(results)} series matching your search:\",\n        reply_markup=series_list_keyboard(results)\n    )\n\nasync def generic_text_search(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    \"\"\"\n    Handles generic text messages, attempting to search for movies or series.\n    This runs after other specific handlers (like commands or reply keyboard regexes).\n    \"\"\"\n    if not update.message or not update.message.text:\n        return\n\n    query = update.message.text.strip().lower()\n\n    if not query:\n        return\n\n    logger.info(f\"User {update.effective_user.id} performing generic search for: '{query}'\")\n\n    all_movies = db_handler.get_all_movies()\n    movie_results = [movie for movie in all_movies if query in movie['name'].lower()]\n\n    all_series = db_handler.get_all_series()\n    series_results = [series for series in all_series if query in series['name'].lower()]\n\n    found_anything = False\n\n    if movie_results:\n        await update.message.reply_text(\n            f\"üîé Found {len(movie_results)} movie(s) matching '{query}':\",\n            reply_markup=movie_list_keyboard(movie_results)\n        )\n        found_anything = True\n\n    if series_results:\n        if found_anything:\n            await asyncio.sleep(0.5)\n        await update.message.reply_text(\n            f\"üîé Found {len(series_results)} series matching '{query}':\",\n            reply_markup=series_list_keyboard(series_results)\n        )\n        found_anything = True\n\n    if not found_anything:\n        await update.message.reply_text(f\"‚ùå No movies or series found matching '{query}'.\")\n\nmovie_search_handler = CommandHandler(\"mv\", search_movie)\nseries_search_handler = CommandHandler(\"sr\", search_series)\ngeneric_search_handler = MessageHandler(filters.TEXT & ~filters.COMMAND, generic_text_search)","size_bytes":3441},"keyboards/reply.py":{"content":"# keyboards/reply.py\n\nfrom telegram import ReplyKeyboardMarkup, KeyboardButton\n\ndef main_reply_keyboard() -> ReplyKeyboardMarkup:\n    \"\"\"Creates the main persistent reply keyboard.\"\"\"\n    keyboard = [\n        [\"üé¨ All Movies\", \"üì∫ All Series\"],\n        [\"üóì Browse by Year\", \"üìö Browse by Category\"], # NEW button added\n        [\"‚ùì Help & FAQ\"]\n    ]\n    return ReplyKeyboardMarkup(keyboard, resize_keyboard=True)\n\ndef done_uploading_reply_keyboard() -> ReplyKeyboardMarkup:\n    \"\"\"Creates a temporary reply keyboard with a 'Done' button for the admin.\"\"\"\n    keyboard = [\n        [KeyboardButton(\"‚úÖ Done Uploading\")]\n    ]\n    return ReplyKeyboardMarkup(keyboard, resize_keyboard=True, one_time_keyboard=True)","size_bytes":722},"handlers/admin/admin_panel.py":{"content":"# handlers/admin/admin_panel.py\nimport logging, uuid\nfrom telegram import Update, InlineKeyboardMarkup, InlineKeyboardButton\nfrom telegram.ext import (\n    ContextTypes, ConversationHandler, CommandHandler,\n    CallbackQueryHandler, MessageHandler, filters,\n)\nfrom database import db_handler\nfrom keyboards import inline as keyboards\nfrom keyboards.reply import done_uploading_reply_keyboard, main_reply_keyboard # Ensure main_reply_keyboard is imported\nfrom utils import constants as const\nfrom utils.decorators import admin_only\nfrom datetime import datetime, timedelta, timezone\n\nlogger = logging.getLogger(__name__)\n\n# --- Entry Point ---\n@admin_only\nasync def admin_panel(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    await update.message.reply_text(\"Welcome to the Admin Panel. Choose an action:\", reply_markup=keyboards.admin_panel_keyboard())\n    return const.SELECTING_ACTION\n\n# --- Add Content Flow ---\nasync def start_add_content(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    query = update.callback_query\n    await query.answer()\n    content_type = \"Movie\" if query.data == const.CALLBACK_ADMIN_ADD_MOVIE else \"Series\"\n    context.user_data['content_type'] = content_type\n    context.user_data['videos'] = []\n    context.user_data['seasons'] = {}\n    await query.edit_message_text(f\"üé¨ Send the name for the new {content_type}.\", reply_markup=keyboards.cancel_keyboard())\n    return const.GET_NAME\n\nasync def get_name(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    context.user_data['name'] = update.message.text\n    await update.message.reply_text(f\"üñºÔ∏è Great! Now, send the cover photo for '{context.user_data['name']}'.\", reply_markup=keyboards.cancel_keyboard())\n    return const.GET_PHOTO\n\nasync def get_photo(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    context.user_data['cover_photo'] = update.message.photo[-1].file_id\n    await update.message.reply_text(\"üóìÔ∏è Got it. Now, please enter the release year (e.g., 2023).\", reply_markup=keyboards.cancel_keyboard())\n    return const.GET_YEAR\n\nasync def get_year(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    try:\n        context.user_data['year'] = int(update.message.text)\n        await update.message.reply_text(\n            \"üìö Enter the categories for this item, separated by commas.\\n\"\n            \"Example: `Action, Comedy, Sci-Fi`\",\n            parse_mode='Markdown',\n            reply_markup=keyboards.cancel_keyboard()\n        )\n        return const.GET_CATEGORIES\n    except ValueError:\n        await update.message.reply_text(\"‚ùå Invalid year. Please enter a number (e.g., 2023).\")\n        return const.GET_YEAR\n\nasync def get_categories(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    \"\"\"Stores categories and asks for the delete timer.\"\"\"\n    categories_raw = update.message.text\n    categories_list = [cat.strip().capitalize() for cat in categories_raw.split(',')]\n    context.user_data['categories'] = categories_list\n    await update.message.reply_text(\n        \"‚è≥ Enter the auto-delete timer in minutes (e.g., 15). Enter 0 for no timer.\",\n        reply_markup=keyboards.cancel_keyboard()\n    )\n    return const.GET_TIMER\n\nasync def get_timer(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    try:\n        timer = int(update.message.text)\n        context.user_data['timer'] = timer\n        if context.user_data['content_type'] == \"Movie\":\n            await update.message.reply_text(\"üé• Please forward the movie file(s). Click 'Done Uploading' below when finished.\", reply_markup=done_uploading_reply_keyboard())\n            return const.GET_CONTENT_VIDEOS\n        else:\n            await update.message.reply_text(\"üî¢ How many seasons does this series have?\", reply_markup=keyboards.cancel_keyboard())\n            return const.GET_SERIES_SEASON_COUNT\n    except ValueError:\n        await update.message.reply_text(\"‚ùå Invalid timer. Please enter a number (e.g., 15).\")\n        return const.GET_TIMER\n\nasync def get_content_videos(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    if update.message.video:\n        context.user_data['videos'].append(update.message.video.file_id)\n        await update.message.reply_text(f\"‚úÖ Video #{len(context.user_data['videos'])} received. Forward more or click Done.\")\n    return const.GET_CONTENT_VIDEOS\n\nasync def get_season_count(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    try:\n        count = int(update.message.text)\n        if count <= 0: raise ValueError()\n        context.user_data['season_total'] = count\n        context.user_data['current_season'] = 1\n        await update.message.reply_text(f\"üé• Forward all episodes for **Season 1**. Click 'Done Uploading' below when finished.\", reply_markup=done_uploading_reply_keyboard(), parse_mode='Markdown')\n        return const.GET_SERIES_EPISODES\n    except ValueError:\n        await update.message.reply_text(\"‚ùå Invalid number. Please enter a positive integer.\")\n        return const.GET_SERIES_SEASON_COUNT\n\nasync def get_series_episodes(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    season_key = str(context.user_data['current_season'])\n    if season_key not in context.user_data['seasons']:\n        context.user_data['seasons'][season_key] = []\n    if update.message.video:\n        context.user_data['seasons'][season_key].append(update.message.video.file_id)\n        await update.message.reply_text(f\"‚úÖ Season {season_key}, Episode #{len(context.user_data['seasons'][season_key])} received.\")\n    return const.GET_SERIES_EPISODES\n\nasync def done_uploading(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    message, content_type = update.message, context.user_data.get('content_type')\n    if not content_type:\n        await message.reply_text(\"An error occurred. Please /admin again.\", reply_markup=main_reply_keyboard())\n        return ConversationHandler.END\n\n    if content_type == \"Movie\":\n        if not context.user_data.get('videos'):\n            await message.reply_text(\"‚ùå You haven't added any videos!\", reply_markup=done_uploading_reply_keyboard())\n            return const.GET_CONTENT_VIDEOS\n        movie_data = {\"id\": str(uuid.uuid4()), **context.user_data}\n        db_handler.add_movie(movie_data)\n        await message.reply_text(f\"‚úÖ Movie '{movie_data['name']}' added!\", reply_markup=main_reply_keyboard())\n    else:\n        current_season, total_seasons = context.user_data.get('current_season', 1), context.user_data.get('season_total', 1)\n        if not context.user_data.get('seasons', {}).get(str(current_season)):\n            await message.reply_text(f\"‚ùå You haven't added episodes for Season {current_season}!\", reply_markup=done_uploading_reply_keyboard())\n            return const.GET_SERIES_EPISODES\n        if current_season < total_seasons:\n            context.user_data['current_season'] += 1\n            await message.reply_text(f\"üé• Season {current_season} done. Forward episodes for **Season {context.user_data['current_season']}**.\", reply_markup=done_uploading_reply_keyboard(), parse_mode='Markdown')\n            return const.GET_SERIES_EPISODES\n        else:\n            series_data = {\"id\": str(uuid.uuid4()), **context.user_data}\n            db_handler.add_series(series_data)\n            await message.reply_text(f\"‚úÖ Series '{series_data['name']}' added!\", reply_markup=main_reply_keyboard())\n\n    context.user_data.clear()\n    return ConversationHandler.END\n\nasync def start_delete_content(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    query = update.callback_query\n    await query.answer()\n    is_movie = query.data == const.CALLBACK_ADMIN_DELETE_MOVIE\n    content_list = db_handler.get_all_movies() if is_movie else db_handler.get_all_series()\n    if not content_list:\n        await query.edit_message_text(f\"No {'movies' if is_movie else 'series'} to delete.\"); return ConversationHandler.END\n    keyboard = [[InlineKeyboardButton(f\"‚ùå {item['name']}\", callback_data=f\"{(const.CALLBACK_DELETE_MOVIE if is_movie else const.CALLBACK_DELETE_SERIES)}{item['id']}\")] for item in content_list]\n    keyboard.append([InlineKeyboardButton(\"üîô Back to Admin Panel\", callback_data=const.CALLBACK_ADMIN_CANCEL)])\n    await query.edit_message_text(f\"Select the {'movie' if is_movie else 'series'} to delete:\", reply_markup=InlineKeyboardMarkup(keyboard))\n    return const.CONFIRM_DELETE\n\nasync def confirm_delete(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    query = update.callback_query\n    await query.answer()\n    is_movie = query.data.startswith(const.CALLBACK_DELETE_MOVIE)\n    content_id = query.data.replace(const.CALLBACK_DELETE_MOVIE if is_movie else const.CALLBACK_DELETE_SERIES, \"\")\n    content = (db_handler.find_movie_by_id(content_id) if is_movie else db_handler.find_series_by_id(content_id))\n    if content:\n        (db_handler.delete_movie_by_id(content_id) if is_movie else db_handler.delete_series_by_id(content_id))\n        await query.edit_message_text(f\"‚úÖ Successfully deleted '{content['name']}'.\")\n    else:\n        await query.edit_message_text(\"‚ùå Content not found or already deleted.\")\n    await query.message.reply_text(\"Admin Panel:\", reply_markup=keyboards.admin_panel_keyboard())\n    return ConversationHandler.END\n\nasync def start_rename_content(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    query = update.callback_query\n    await query.answer()\n    is_movie = query.data == const.CALLBACK_ADMIN_RENAME_MOVIE\n    context.user_data['is_movie'] = is_movie\n    content_list = db_handler.get_all_movies() if is_movie else db_handler.get_all_series()\n    if not content_list:\n        await query.edit_message_text(f\"No {'movies' if is_movie else 'series'} to rename.\"); return ConversationHandler.END\n    keyboard = [[InlineKeyboardButton(f\"‚úèÔ∏è {item['name']}\", callback_data=f\"{(const.CALLBACK_RENAME_MOVIE if is_movie else const.CALLBACK_RENAME_SERIES)}{item['id']}\")] for item in content_list]\n    keyboard.append([InlineKeyboardButton(\"üîô Back to Admin Panel\", callback_data=const.CALLBACK_ADMIN_CANCEL)])\n    await query.edit_message_text(f\"Select the {'movie' if is_movie else 'series'} to rename:\", reply_markup=InlineKeyboardMarkup(keyboard))\n    return const.SELECT_RENAME_ITEM\n\nasync def get_item_to_rename(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    query = update.callback_query\n    await query.answer()\n    is_movie = context.user_data['is_movie']\n    content_id = query.data.replace(const.CALLBACK_RENAME_MOVIE if is_movie else const.CALLBACK_RENAME_SERIES, \"\")\n    context.user_data['content_id'] = content_id\n    content = db_handler.find_movie_by_id(content_id) if is_movie else db_handler.find_series_by_id(content_id)\n    if not content:\n        await query.edit_message_text(\"Content not found.\"); return ConversationHandler.END\n    await query.edit_message_text(f\"Current name: `{content['name']}`\\n\\nPlease send the new name.\", parse_mode='Markdown', reply_markup=keyboards.cancel_keyboard())\n    return const.GET_NEW_NAME\n\nasync def get_new_name_and_save(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    new_name, is_movie, content_id = update.message.text, context.user_data['is_movie'], context.user_data['content_id']\n    all_content = db_handler.get_all_movies() if is_movie else db_handler.get_all_series()\n    for item in all_content:\n        if item['id'] == content_id:\n            item['name'] = new_name; break\n    (db_handler.save_data(db_handler.MOVIES_DB_PATH, all_content) if is_movie else db_handler.save_data(db_handler.SERIES_DB_PATH, all_content))\n    await update.message.reply_text(f\"‚úÖ Successfully renamed to '{new_name}'.\", reply_markup=main_reply_keyboard())\n    context.user_data.clear()\n    return ConversationHandler.END\n\n# --- NEW: Edit Series Flow ---\nasync def start_edit_series(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    \"\"\"Entry point for editing series.\"\"\"\n    query = update.callback_query\n    await query.answer()\n    series_list = db_handler.get_all_series()\n    if not series_list:\n        await query.edit_message_text(\"No series available to edit.\")\n        return ConversationHandler.END\n    await query.edit_message_text(\"Select a series to edit:\", reply_markup=keyboards.edit_series_list_keyboard(series_list, page=0))\n    return const.SELECT_EDIT_SERIES\n\nasync def handle_edit_series_pagination(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    \"\"\"Handle pagination of series list.\"\"\"\n    query = update.callback_query\n    await query.answer()\n    page = int(query.data.replace(const.CALLBACK_EDIT_SERIES_PAGE, \"\"))\n    series_list = db_handler.get_all_series()\n    await query.edit_message_text(\"Select a series to edit:\", reply_markup=keyboards.edit_series_list_keyboard(series_list, page=page))\n    return const.SELECT_EDIT_SERIES\n\nasync def select_series_for_edit(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    \"\"\"When a series is selected, show its seasons.\"\"\"\n    query = update.callback_query\n    await query.answer()\n    series_id = query.data.replace(const.CALLBACK_EDIT_SERIES_SELECT, \"\")\n    series = db_handler.find_series_by_id(series_id)\n    if not series:\n        await query.edit_message_text(\"Series not found.\")\n        return ConversationHandler.END\n    context.user_data['edit_series_id'] = series_id\n    await query.edit_message_text(\n        f\"Editing: **{series['name']}**\\n\\nSelect a season to edit:\",\n        parse_mode='Markdown',\n        reply_markup=keyboards.edit_season_selection_keyboard(series)\n    )\n    return const.SELECT_EDIT_SEASON\n\nasync def select_season_for_edit(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    \"\"\"When a season is selected, show add/remove options.\"\"\"\n    query = update.callback_query\n    await query.answer()\n    data = query.data.replace(const.CALLBACK_EDIT_SEASON_SELECT, \"\")\n    series_id, season_num = data.split(\"_\")\n    series = db_handler.find_series_by_id(series_id)\n    if not series or season_num not in series['seasons']:\n        await query.edit_message_text(\"Season not found.\")\n        return ConversationHandler.END\n    context.user_data['edit_season_num'] = season_num\n    await query.edit_message_text(\n        f\"Season {season_num} - {len(series['seasons'][season_num])} episodes\\n\\nWhat would you like to do?\",\n        reply_markup=keyboards.edit_action_keyboard()\n    )\n    return const.SELECT_EDIT_ACTION\n\nasync def start_add_episodes(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    \"\"\"Start adding episodes to the selected season.\"\"\"\n    query = update.callback_query\n    await query.answer()\n    series_id = context.user_data['edit_series_id']\n    season_num = context.user_data['edit_season_num']\n    series = db_handler.find_series_by_id(series_id)\n    if not series or season_num not in series['seasons']:\n        await query.edit_message_text(\"Season not found.\")\n        return ConversationHandler.END\n    existing_count = len(series['seasons'][season_num])\n    context.user_data['new_episodes'] = []\n    await query.delete_message()\n    await query.message.reply_text(\n        f\"üìπ Season {season_num} currently has {existing_count} episodes.\\n\\n\"\n        f\"Forward the new episode videos. They will be numbered starting from Episode {existing_count + 1}.\\n\\n\"\n        f\"Click 'Done Uploading' when finished.\",\n        reply_markup=done_uploading_reply_keyboard()\n    )\n    return const.ADD_SERIES_EPISODES\n\nasync def handle_add_episode_upload(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    \"\"\"Handle episode video uploads.\"\"\"\n    if update.message.video:\n        context.user_data['new_episodes'].append(update.message.video.file_id)\n        series_id = context.user_data['edit_series_id']\n        season_num = context.user_data['edit_season_num']\n        series = db_handler.find_series_by_id(series_id)\n        if series and season_num in series['seasons']:\n            existing_count = len(series['seasons'][season_num])\n            new_episode_num = existing_count + len(context.user_data['new_episodes'])\n            await update.message.reply_text(f\"‚úÖ Episode {new_episode_num} received.\")\n    return const.ADD_SERIES_EPISODES\n\nasync def done_adding_episodes(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    \"\"\"Save the new episodes to the series.\"\"\"\n    series_id = context.user_data['edit_series_id']\n    season_num = context.user_data['edit_season_num']\n    new_episodes = context.user_data.get('new_episodes', [])\n    \n    if not new_episodes:\n        await update.message.reply_text(\"‚ùå You haven't added any episodes!\", reply_markup=done_uploading_reply_keyboard())\n        return const.ADD_SERIES_EPISODES\n    \n    series = db_handler.find_series_by_id(series_id)\n    if not series or season_num not in series['seasons']:\n        await update.message.reply_text(\"‚ùå Series or season not found!\", reply_markup=main_reply_keyboard())\n        context.user_data.clear()\n        return ConversationHandler.END\n    \n    series['seasons'][season_num].extend(new_episodes)\n    db_handler.update_series(series_id, series)\n    \n    await update.message.reply_text(\n        f\"‚úÖ Successfully added {len(new_episodes)} episode(s) to Season {season_num} of '{series['name']}'!\",\n        reply_markup=main_reply_keyboard()\n    )\n    context.user_data.clear()\n    return ConversationHandler.END\n\nasync def start_remove_episodes(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    \"\"\"Show episodes that can be removed.\"\"\"\n    query = update.callback_query\n    await query.answer()\n    series_id = context.user_data['edit_series_id']\n    season_num = context.user_data['edit_season_num']\n    series = db_handler.find_series_by_id(series_id)\n    if not series or season_num not in series['seasons']:\n        await query.edit_message_text(\"Season not found.\")\n        return ConversationHandler.END\n    episodes = series['seasons'][season_num]\n    \n    if not episodes:\n        await query.edit_message_text(\"No episodes to remove.\")\n        return ConversationHandler.END\n    \n    await query.edit_message_text(\n        f\"Season {season_num} - Select episodes to remove:\",\n        reply_markup=keyboards.remove_episode_keyboard(series_id, season_num, episodes)\n    )\n    return const.REMOVE_SERIES_EPISODES\n\nasync def handle_remove_episode(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    \"\"\"Remove a specific episode.\"\"\"\n    query = update.callback_query\n    await query.answer()\n    data = query.data.replace(const.CALLBACK_REMOVE_EPISODE, \"\")\n    series_id, season_num, episode_index = data.split(\"_\")\n    episode_index = int(episode_index)\n    \n    series = db_handler.find_series_by_id(series_id)\n    if not series or season_num not in series['seasons']:\n        await query.edit_message_text(\"Season not found.\")\n        return ConversationHandler.END\n    \n    if episode_index < 0 or episode_index >= len(series['seasons'][season_num]):\n        await query.answer(\"Episode not found.\", show_alert=True)\n        return const.REMOVE_SERIES_EPISODES\n    \n    removed_episode = series['seasons'][season_num].pop(episode_index)\n    db_handler.update_series(series_id, series)\n    \n    episodes = series['seasons'][season_num]\n    if not episodes:\n        await query.edit_message_text(\n            f\"‚úÖ Episode {episode_index + 1} removed. No episodes left in Season {season_num}.\",\n            reply_markup=main_reply_keyboard()\n        )\n        context.user_data.clear()\n        return ConversationHandler.END\n    \n    await query.edit_message_text(\n        f\"‚úÖ Episode {episode_index + 1} removed.\\n\\nSeason {season_num} now has {len(episodes)} episode(s). Select another to remove or click Done:\",\n        reply_markup=keyboards.remove_episode_keyboard(series_id, season_num, episodes)\n    )\n    return const.REMOVE_SERIES_EPISODES\n\nasync def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    context.user_data.clear()\n    if update.callback_query:\n        await update.callback_query.answer()\n        # Edit the message where the inline keyboard was, if possible\n        try:\n            await update.callback_query.edit_message_text(\"Operation cancelled.\", reply_markup=main_reply_keyboard()) # <--- MODIFIED HERE\n        except Exception as e:\n            logger.warning(f\"Could not edit message on cancel via callback: {e}\")\n            await update.callback_query.message.reply_text(\"Operation cancelled.\", reply_markup=main_reply_keyboard()) # Fallback\n    else:\n        await update.message.reply_text(\"Operation cancelled.\", reply_markup=main_reply_keyboard()) # <--- MODIFIED HERE\n    return ConversationHandler.END\n\nadmin_conversation_handler = ConversationHandler(\n    entry_points=[CommandHandler(\"admin\", admin_panel)],\n    states={\n        const.SELECTING_ACTION: [\n            CallbackQueryHandler(start_add_content, pattern=f\"^{const.CALLBACK_ADMIN_ADD_MOVIE}$|^{const.CALLBACK_ADMIN_ADD_SERIES}$\"),\n            CallbackQueryHandler(start_delete_content, pattern=f\"^{const.CALLBACK_ADMIN_DELETE_MOVIE}$|^{const.CALLBACK_ADMIN_DELETE_SERIES}$\"),\n            CallbackQueryHandler(start_rename_content, pattern=f\"^{const.CALLBACK_ADMIN_RENAME_MOVIE}$|^{const.CALLBACK_ADMIN_RENAME_SERIES}$\"),\n            CallbackQueryHandler(start_edit_series, pattern=f\"^{const.CALLBACK_ADMIN_EDIT_SERIES}$\"),\n        ],\n        const.GET_NAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, get_name)],\n        const.GET_PHOTO: [MessageHandler(filters.PHOTO, get_photo)],\n        const.GET_YEAR: [MessageHandler(filters.TEXT & ~filters.COMMAND, get_year)],\n        const.GET_CATEGORIES: [MessageHandler(filters.TEXT & ~filters.COMMAND, get_categories)],\n        const.GET_TIMER: [MessageHandler(filters.TEXT & ~filters.COMMAND, get_timer)],\n        const.GET_CONTENT_VIDEOS: [MessageHandler(filters.VIDEO, get_content_videos), MessageHandler(filters.Regex(\"^‚úÖ Done Uploading$\"), done_uploading)],\n        const.GET_SERIES_SEASON_COUNT: [MessageHandler(filters.TEXT & ~filters.COMMAND, get_season_count)],\n        const.GET_SERIES_EPISODES: [MessageHandler(filters.VIDEO, get_series_episodes), MessageHandler(filters.Regex(\"^‚úÖ Done Uploading$\"), done_uploading)],\n        const.CONFIRM_DELETE: [CallbackQueryHandler(confirm_delete, pattern=f\"^{const.CALLBACK_DELETE_MOVIE}|^({const.CALLBACK_DELETE_SERIES})\"), CallbackQueryHandler(cancel, pattern=f\"^{const.CALLBACK_ADMIN_CANCEL}$\")],\n        const.SELECT_RENAME_ITEM: [CallbackQueryHandler(get_item_to_rename, pattern=f\"^{const.CALLBACK_RENAME_MOVIE}|^({const.CALLBACK_RENAME_SERIES})\")],\n        const.GET_NEW_NAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, get_new_name_and_save)],\n        # --- NEW Edit Series States Handlers ---\n        const.SELECT_EDIT_SERIES: [\n            CallbackQueryHandler(handle_edit_series_pagination, pattern=f\"^{const.CALLBACK_EDIT_SERIES_PAGE}\"),\n            CallbackQueryHandler(select_series_for_edit, pattern=f\"^{const.CALLBACK_EDIT_SERIES_SELECT}\"),\n            CallbackQueryHandler(cancel, pattern=f\"^{const.CALLBACK_ADMIN_CANCEL}$\"),\n        ],\n        const.SELECT_EDIT_SEASON: [\n            CallbackQueryHandler(select_season_for_edit, pattern=f\"^{const.CALLBACK_EDIT_SEASON_SELECT}\"),\n            CallbackQueryHandler(start_edit_series, pattern=f\"^{const.CALLBACK_ADMIN_EDIT_SERIES}$\"),\n        ],\n        const.SELECT_EDIT_ACTION: [\n            CallbackQueryHandler(start_add_episodes, pattern=f\"^{const.CALLBACK_EDIT_ACTION_ADD}$\"),\n            CallbackQueryHandler(start_remove_episodes, pattern=f\"^{const.CALLBACK_EDIT_ACTION_REMOVE}$\"),\n            CallbackQueryHandler(start_edit_series, pattern=f\"^{const.CALLBACK_ADMIN_EDIT_SERIES}$\"),\n        ],\n        const.ADD_SERIES_EPISODES: [\n            MessageHandler(filters.VIDEO, handle_add_episode_upload),\n            MessageHandler(filters.Regex(\"^‚úÖ Done Uploading$\"), done_adding_episodes),\n        ],\n        const.REMOVE_SERIES_EPISODES: [\n            CallbackQueryHandler(handle_remove_episode, pattern=f\"^{const.CALLBACK_REMOVE_EPISODE}\"),\n            CallbackQueryHandler(start_edit_series, pattern=f\"^{const.CALLBACK_ADMIN_EDIT_SERIES}$\"),\n        ],\n    },\n    fallbacks=[CallbackQueryHandler(cancel, pattern=f\"^{const.CALLBACK_ADMIN_CANCEL}$\"), CommandHandler(\"cancel\", cancel)],\n    per_message=False\n)","size_bytes":24372},"middleware.py":{"content":"# middleware.py\nimport logging\nfrom telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup\nfrom telegram.ext import ContextTypes\nfrom telegram.error import TelegramError, BadRequest\nfrom telegram.constants import ParseMode, ChatMemberStatus\nfrom telegram.helpers import escape_markdown\nimport config\n\nlogger = logging.getLogger(__name__)\n\nasync def force_join_middleware(update: Update, context: ContextTypes.DEFAULT_TYPE) -> bool:\n    \"\"\"\n    Middleware that checks channel membership. Returns True if allowed, False if blocked.\n    \"\"\"\n    if not update.effective_user:\n        return True\n\n    user = update.effective_user\n\n    if user.id in config.ADMIN_IDS:\n        return True\n\n    if not config.FORCE_JOIN_CHANNEL:\n        return True\n\n    try:\n        member = await context.bot.get_chat_member(chat_id=config.FORCE_JOIN_CHANNEL, user_id=user.id)\n        if member.status in [ChatMemberStatus.MEMBER, ChatMemberStatus.ADMINISTRATOR, ChatMemberStatus.OWNER, ChatMemberStatus.RESTRICTED]:\n            return True\n            \n    except BadRequest as e:\n        if \"user not found\" in str(e).lower():\n            pass\n        else:\n            logger.error(f\"BOT PERMISSION ERROR in {config.FORCE_JOIN_CHANNEL}: {e}. Bot must be an admin.\")\n            # Ensure this reply is also MarkdownV2 safe if it contains any special chars\n            await update.effective_message.reply_text(\n                escape_markdown(\"Sorry, the bot is experiencing a technical issue. Please notify an admin.\", version=2), \n                parse_mode=ParseMode.MARKDOWN_V2\n            )\n            return True\n    except TelegramError as e:\n        logger.error(f\"TelegramError checking membership for user {user.id}: {e}. Allowing user to pass.\")\n        return True\n    \n    # --- If all checks fail, the user is not a member. Block them. ---\n    logger.info(f\"User {user.id} denied access: Not a member of {config.FORCE_JOIN_CHANNEL}.\")\n    \n    join_url = f\"https://t.me/{config.FORCE_JOIN_CHANNEL.lstrip('@')}\"\n    \n    # Construct the raw string, then escape it entirely for MarkdownV2\n    raw_text = (\n        f\"üëã **Access Denied | ·Ä°·Äû·ÄØ·Ä∂·Ä∏·Äï·Äº·ÄØ·ÄÅ·ÄΩ·ÄÑ·Ä∑·Ä∫·Äô·Äõ·Äæ·Ä≠·Äï·Ä´**\\n\\n\"\n        f\"To use this bot, you must first join our official channel: {config.FORCE_JOIN_CHANNEL}\\n\"\n        f\"·Ä§·Äò·Ä±·Ä¨·Ä∑·Äê·Ä∫·ÄÄ·Ä≠·ÄØ ·Ä°·Äû·ÄØ·Ä∂·Ä∏·Äï·Äº·ÄØ·Äõ·Äî·Ä∫·Åä ·ÄÄ·Äª·ÄΩ·Äî·Ä∫·ÄØ·Äï·Ä∫·Äê·Ä≠·ÄØ·Ä∑·Åè·Äê·Äõ·Ä¨·Ä∏·Äù·ÄÑ·Ä∫·ÄÅ·Äª·Äî·Ä∫·Äî·Äö·Ä∫·Äñ·Äº·ÄÖ·Ä∫·Äû·Ä±·Ä¨ {config.FORCE_JOIN_CHANNEL} ·Äû·Ä≠·ÄØ·Ä∑ ·Ä¶·Ä∏·ÄÖ·ÄΩ·Ä¨·Äù·ÄÑ·Ä∫·Äõ·Ä±·Ä¨·ÄÄ·Ä∫·Äõ·Äï·Ä´·Äô·Ää·Ä∫·Åã\"\n    )\n    # Use escape_markdown for the entire string\n    escaped_text = escape_markdown(raw_text, version=2)\n\n    keyboard = InlineKeyboardMarkup([\n        [InlineKeyboardButton(\"‚û°Ô∏è Join Channel | Channel ·Äû·Ä≠·ÄØ·Ä∑ Join ·Äï·Ä´\", url=join_url)],\n        [InlineKeyboardButton(\"‚úÖ I Have Joined | Join ·Äï·Äº·ÄÆ·Ä∏·Äï·Ä´·Äï·Äº·ÄÆ\", callback_data=\"check_join_status\")]\n    ])\n    \n    if update.callback_query:\n        alert_text = (\n            f\"You have not joined the {config.FORCE_JOIN_CHANNEL} channel yet.\\n\"\n            f\"·Äû·ÄÑ·Ä∫ {config.FORCE_JOIN_CHANNEL} ·Äû·Ä≠·ÄØ·Ä∑ Join ·Äõ·Äû·Ä±·Ä∏·ÄÅ·Äº·ÄÑ·Ä∫·Ä∏·Äô·Äõ·Äæ·Ä≠·Äï·Ä´·Åã\\n\\n\"\n            \"Please join and then press the button again.\\n\"\n            \"·ÄÄ·Äª·Ä±·Ä∏·Äá·Ä∞·Ä∏·Äï·Äº·ÄØ·Åç Join ·Äï·Äº·ÄÆ·Ä∏·Äî·Ä±·Ä¨·ÄÄ·Ä∫ ·ÄÅ·Äú·ÄØ·Äê·Ä∫·ÄÄ·Ä≠·ÄØ·Äï·Äº·Äî·Ä∫·Äî·Äæ·Ä≠·Äï·Ä∫·Äï·Ä´·Åã\"\n        )\n        await update.callback_query.answer(alert_text, show_alert=True)\n    else:\n        # Use the fully escaped text and set parse_mode\n        await update.effective_message.reply_text(escaped_text, reply_markup=keyboard, parse_mode=ParseMode.MARKDOWN_V2)\n        \n    return False\n\n# ... (rest of middleware.py)","size_bytes":3767},"database/init.py":{"content":"# database/__init__.py\n\nfrom . import db_handler\nfrom . import db_premium # NEW: Import the premium database handler","size_bytes":116},"keyboards/inline.py":{"content":"# keyboards/inline.py\nfrom telegram import InlineKeyboardButton, InlineKeyboardMarkup\nfrom database import db_handler\nfrom utils import constants as const\nfrom typing import List, Dict, Any\n\ndef admin_panel_keyboard() -> InlineKeyboardMarkup:\n    keyboard = [\n        [\n            InlineKeyboardButton(\"‚ûï Add Movie\", callback_data=const.CALLBACK_ADMIN_ADD_MOVIE),\n            InlineKeyboardButton(\"‚ûï Add Series\", callback_data=const.CALLBACK_ADMIN_ADD_SERIES),\n        ],\n        [\n            InlineKeyboardButton(\"‚ùå Delete Movie\", callback_data=const.CALLBACK_ADMIN_DELETE_MOVIE),\n            InlineKeyboardButton(\"‚ùå Delete Series\", callback_data=const.CALLBACK_ADMIN_DELETE_SERIES),\n        ],\n        [\n            InlineKeyboardButton(\"‚úèÔ∏è Rename Movie\", callback_data=const.CALLBACK_ADMIN_RENAME_MOVIE),\n            InlineKeyboardButton(\"‚úèÔ∏è Rename Series\", callback_data=const.CALLBACK_ADMIN_RENAME_SERIES),\n        ],\n        [\n            InlineKeyboardButton(\"üìù Edit Series\", callback_data=const.CALLBACK_ADMIN_EDIT_SERIES)\n        ]\n    ]\n    return InlineKeyboardMarkup(keyboard)\n\ndef category_selection_keyboard(page: int = 0) -> InlineKeyboardMarkup:\n    \"\"\"Generates a paginated keyboard for browsing content by category.\"\"\"\n    categories = db_handler.get_all_unique_categories()\n    if not categories:\n        keyboard = [\n            [InlineKeyboardButton(\"No categories available yet.\", callback_data=\"no_op\")],\n            [InlineKeyboardButton(\"üîô Back\", callback_data=\"back_to_main_menu\")]\n        ]\n        return InlineKeyboardMarkup(keyboard)\n\n    per_page = 10\n    start, end = page * per_page, (page + 1) * per_page\n    paginated_categories = categories[start:end]\n\n    keyboard = []\n    # Create 2 columns\n    for i in range(0, len(paginated_categories), 2):\n        row = [\n            InlineKeyboardButton(cat, callback_data=f\"{const.CALLBACK_CATEGORY_SELECT}{cat}\")\n            for cat in paginated_categories[i:i+2]\n        ]\n        keyboard.append(row)\n    \n    nav_buttons = []\n    if page > 0:\n        nav_buttons.append(InlineKeyboardButton(\"‚¨ÖÔ∏è Prev\", callback_data=f\"{const.CALLBACK_CATEGORY_PAGE}{page-1}\"))\n    if end < len(categories):\n        nav_buttons.append(InlineKeyboardButton(\"Next ‚û°Ô∏è\", callback_data=f\"{const.CALLBACK_CATEGORY_PAGE}{page+1}\"))\n    if nav_buttons:\n        keyboard.append(nav_buttons)\n\n    keyboard.append([InlineKeyboardButton(\"üîô Back\", callback_data=\"back_to_main_menu\")])\n    return InlineKeyboardMarkup(keyboard)\n\ndef category_content_type_keyboard(category: str) -> InlineKeyboardMarkup:\n    \"\"\"Asks the user to choose between Movies or Series for a specific category.\"\"\"\n    keyboard = [\n        [\n            InlineKeyboardButton(\"üé¨ Movies\", callback_data=f\"{const.CALLBACK_CATEGORY_CONTENT_TYPE}{category}_movies\"),\n            InlineKeyboardButton(\"üì∫ Series\", callback_data=f\"{const.CALLBACK_CATEGORY_CONTENT_TYPE}{category}_series\"),\n        ],\n        [InlineKeyboardButton(\"üîô Back to Category Selection\", callback_data=\"browse_category_from_callback\")]\n    ]\n    return InlineKeyboardMarkup(keyboard)\n\ndef year_selection_keyboard(page: int = 0) -> InlineKeyboardMarkup:\n    years = db_handler.get_all_unique_years()\n    if not years:\n        keyboard = [\n            [InlineKeyboardButton(\"No content available yet.\", callback_data=\"no_op\")],\n            [InlineKeyboardButton(\"üîô Back\", callback_data=\"back_to_main_menu\")]\n        ]\n        return InlineKeyboardMarkup(keyboard)\n\n    per_page = 10\n    start, end = page * per_page, (page + 1) * per_page\n    paginated_years = years[start:end]\n    keyboard = []\n    for i in range(0, len(paginated_years), 2):\n        row = [\n            InlineKeyboardButton(str(year), callback_data=f\"{const.CALLBACK_YEAR_SELECT}{year}\")\n            for year in paginated_years[i:i+2]\n        ]\n        keyboard.append(row)\n    nav_buttons = []\n    if page > 0:\n        nav_buttons.append(InlineKeyboardButton(\"‚¨ÖÔ∏è Prev\", callback_data=f\"{const.CALLBACK_YEAR_PAGE}{page-1}\"))\n    if end < len(years):\n        nav_buttons.append(InlineKeyboardButton(\"Next ‚û°Ô∏è\", callback_data=f\"{const.CALLBACK_YEAR_PAGE}{page+1}\"))\n    if nav_buttons:\n        keyboard.append(nav_buttons)\n    keyboard.append([InlineKeyboardButton(\"üîô Back\", callback_data=\"back_to_main_menu\")])\n    return InlineKeyboardMarkup(keyboard)\n\ndef year_content_type_keyboard(year: int) -> InlineKeyboardMarkup:\n    keyboard = [\n        [\n            InlineKeyboardButton(\"üé¨ Movies\", callback_data=f\"{const.CALLBACK_YEAR_CONTENT_TYPE}{year}_movies\"),\n            InlineKeyboardButton(\"üì∫ Series\", callback_data=f\"{const.CALLBACK_YEAR_CONTENT_TYPE}{year}_series\"),\n        ],\n        [InlineKeyboardButton(\"üîô Back to Year Selection\", callback_data=\"browse_year_from_callback\")]\n    ]\n    return InlineKeyboardMarkup(keyboard)\n\ndef movie_list_keyboard(movies: List[Dict[str, Any]], page: int = 0) -> InlineKeyboardMarkup:\n    per_page = 10\n    start, end = page * per_page, (page + 1) * per_page\n    paginated_movies = movies[start:end]\n    keyboard = [\n        [InlineKeyboardButton(f\"üé¨ {movie['name']} ({movie['year']})\", callback_data=f\"{const.CALLBACK_MOVIE_SELECT}{movie['id']}\")]\n        for movie in paginated_movies\n    ]\n    nav_buttons = []\n    if page > 0:\n        nav_buttons.append(InlineKeyboardButton(\"‚¨ÖÔ∏è Prev\", callback_data=f\"{const.CALLBACK_MOVIE_PAGE}{page-1}\"))\n    if end < len(movies):\n        nav_buttons.append(InlineKeyboardButton(\"Next ‚û°Ô∏è\", callback_data=f\"{const.CALLBACK_MOVIE_PAGE}{page+1}\"))\n    if nav_buttons:\n        keyboard.append(nav_buttons)\n    keyboard.append([InlineKeyboardButton(\"üîô Back\", callback_data=\"back_to_main_menu\")])\n    return InlineKeyboardMarkup(keyboard)\n\ndef series_list_keyboard(series_list: List[Dict[str, Any]], page: int = 0) -> InlineKeyboardMarkup:\n    per_page = 10\n    start, end = page * per_page, (page + 1) * per_page\n    paginated_series = series_list[start:end]\n    keyboard = [\n        [InlineKeyboardButton(f\"üì∫ {series['name']} ({series['year']})\", callback_data=f\"{const.CALLBACK_SERIES_SELECT}{series['id']}\")]\n        for series in paginated_series\n    ]\n    nav_buttons = []\n    if page > 0:\n        nav_buttons.append(InlineKeyboardButton(\"‚¨ÖÔ∏è Prev\", callback_data=f\"{const.CALLBACK_SERIES_PAGE}{page-1}\"))\n    if end < len(series_list):\n        nav_buttons.append(InlineKeyboardButton(\"Next ‚û°Ô∏è\", callback_data=f\"{const.CALLBACK_SERIES_PAGE}{page+1}\"))\n    if nav_buttons:\n        keyboard.append(nav_buttons)\n    keyboard.append([InlineKeyboardButton(\"üîô Back\", callback_data=\"back_to_main_menu\")])\n    return InlineKeyboardMarkup(keyboard)\n    \ndef series_season_keyboard(series: Dict[str, Any]) -> InlineKeyboardMarkup:\n    keyboard = [\n        [InlineKeyboardButton(f\"Season {season_num}\", callback_data=f\"{const.CALLBACK_SEASON_SELECT}{series['id']}_{season_num}\")]\n        for season_num in sorted(series['seasons'].keys(), key=int)\n    ]\n    return InlineKeyboardMarkup(keyboard)\n\ndef get_file_again_keyboard(content_type: str, content_id: str) -> InlineKeyboardMarkup:\n    callback_data = f\"{const.CALLBACK_REGET_MOVIE}{content_id}\" if content_type == 'movie' else f\"{const.CALLBACK_REGET_SERIES}{content_id}\"\n    keyboard = [[InlineKeyboardButton(\"üîÅ GET FILE AGAIN!\", callback_data=callback_data)]]\n    return InlineKeyboardMarkup(keyboard)\n\ndef cancel_keyboard() -> InlineKeyboardMarkup:\n    keyboard = [[InlineKeyboardButton(\"üîô Cancel\", callback_data=const.CALLBACK_ADMIN_CANCEL)]]\n    return InlineKeyboardMarkup(keyboard)\n\ndef edit_series_list_keyboard(series_list: List[Dict[str, Any]], page: int = 0) -> InlineKeyboardMarkup:\n    \"\"\"Paginated keyboard for selecting a series to edit.\"\"\"\n    per_page = 10\n    start, end = page * per_page, (page + 1) * per_page\n    paginated_series = series_list[start:end]\n    keyboard = [\n        [InlineKeyboardButton(f\"üìù {series['name']} ({series['year']})\", callback_data=f\"{const.CALLBACK_EDIT_SERIES_SELECT}{series['id']}\")]\n        for series in paginated_series\n    ]\n    nav_buttons = []\n    if page > 0:\n        nav_buttons.append(InlineKeyboardButton(\"‚¨ÖÔ∏è Prev\", callback_data=f\"{const.CALLBACK_EDIT_SERIES_PAGE}{page-1}\"))\n    if end < len(series_list):\n        nav_buttons.append(InlineKeyboardButton(\"Next ‚û°Ô∏è\", callback_data=f\"{const.CALLBACK_EDIT_SERIES_PAGE}{page+1}\"))\n    if nav_buttons:\n        keyboard.append(nav_buttons)\n    keyboard.append([InlineKeyboardButton(\"üîô Back to Admin Panel\", callback_data=const.CALLBACK_ADMIN_CANCEL)])\n    return InlineKeyboardMarkup(keyboard)\n\ndef edit_season_selection_keyboard(series: Dict[str, Any]) -> InlineKeyboardMarkup:\n    \"\"\"Keyboard for selecting a season to edit.\"\"\"\n    keyboard = [\n        [InlineKeyboardButton(f\"Season {season_num} ({len(episodes)} episodes)\", callback_data=f\"{const.CALLBACK_EDIT_SEASON_SELECT}{series['id']}_{season_num}\")]\n        for season_num, episodes in sorted(series['seasons'].items(), key=lambda x: int(x[0]))\n    ]\n    keyboard.append([InlineKeyboardButton(\"üîô Back to Series List\", callback_data=const.CALLBACK_ADMIN_EDIT_SERIES)])\n    return InlineKeyboardMarkup(keyboard)\n\ndef edit_action_keyboard() -> InlineKeyboardMarkup:\n    \"\"\"Keyboard for choosing to add or remove episodes.\"\"\"\n    keyboard = [\n        [InlineKeyboardButton(\"‚ûï Add Episodes\", callback_data=const.CALLBACK_EDIT_ACTION_ADD)],\n        [InlineKeyboardButton(\"‚ùå Remove Episodes\", callback_data=const.CALLBACK_EDIT_ACTION_REMOVE)],\n        [InlineKeyboardButton(\"üîô Back\", callback_data=const.CALLBACK_ADMIN_EDIT_SERIES)]\n    ]\n    return InlineKeyboardMarkup(keyboard)\n\ndef remove_episode_keyboard(series_id: str, season_num: str, episodes: List[str]) -> InlineKeyboardMarkup:\n    \"\"\"Keyboard for selecting episodes to remove.\"\"\"\n    keyboard = [\n        [InlineKeyboardButton(f\"‚ùå Episode {i+1}\", callback_data=f\"{const.CALLBACK_REMOVE_EPISODE}{series_id}_{season_num}_{i}\")]\n        for i in range(len(episodes))\n    ]\n    keyboard.append([InlineKeyboardButton(\"‚úÖ Done\", callback_data=const.CALLBACK_ADMIN_EDIT_SERIES)])\n    return InlineKeyboardMarkup(keyboard)","size_bytes":10144},"replit.md":{"content":"# Cineverse Bot - Telegram Movie & Series Bot\n\n## Overview\nCineverse Bot is a Telegram bot that provides a platform for users to search, browse, and access movies and series. The bot is completely free and includes admin controls and content management capabilities.\n\n## Current State\n- **Status**: Bot is successfully running in Replit environment\n- **Language**: Python 3.11\n- **Framework**: python-telegram-bot library\n- **Database**: JSON file-based storage (movies_db.json, series_db.json)\n- **Access**: Free for all users - no premium membership required\n\n## Recent Changes\n- **2025-10-20**: Removed all premium and payment features - bot is now completely free\n  - Removed premium membership system - bot is now free for all users\n  - Removed payment methods and pricing information from config\n  - Removed @premium_only decorators from all handlers\n  - Removed /myplan command and premium user management\n  - Removed premium user database functionality (deleted db_premium.py, premium_users_db.json)\n  - Updated help text to reflect free access\n  - Removed admin panel premium user management features\n  - Cleaned up premium-related constants and imports from utils/constants.py, utils/decorators.py, and middleware.py\n- **2025-10-20**: Secure bot token configuration\n  - Removed hardcoded bot token from config.py\n  - Bot token now stored securely in environment variables\n- **2025-10-05**: GitHub import completed and configured for Replit\n  - Installed Python 3.11 and python-telegram-bot dependencies\n  - Updated config.py to use environment variables for BOT_TOKEN\n  - Created .gitignore for Python project\n  - Configured workflow to run the bot\n  - Cleaned up duplicate mvbotgit folder and zip files\n\n## Project Architecture\n\n### Directory Structure\n```\n.\n‚îú‚îÄ‚îÄ bot.py                 # Main bot entry point\n‚îú‚îÄ‚îÄ config.py             # Configuration (BOT_TOKEN, ADMIN_IDS, channels)\n‚îú‚îÄ‚îÄ middleware.py         # Force join channel middleware\n‚îú‚îÄ‚îÄ database/             # JSON-based database\n‚îÇ   ‚îú‚îÄ‚îÄ db_handler.py     # Movie/Series CRUD operations\n‚îÇ   ‚îú‚îÄ‚îÄ movies_db.json    # Movies storage\n‚îÇ   ‚îî‚îÄ‚îÄ series_db.json    # Series storage\n‚îú‚îÄ‚îÄ handlers/             # Message and command handlers\n‚îÇ   ‚îú‚îÄ‚îÄ admin/            # Admin panel handlers\n‚îÇ   ‚îî‚îÄ‚îÄ user/             # User-facing handlers (search, browsing, start)\n‚îú‚îÄ‚îÄ keyboards/            # Telegram keyboard layouts\n‚îÇ   ‚îú‚îÄ‚îÄ inline.py         # Inline keyboards\n‚îÇ   ‚îî‚îÄ‚îÄ reply.py          # Reply keyboards\n‚îî‚îÄ‚îÄ utils/                # Helper utilities\n    ‚îú‚îÄ‚îÄ constants.py      # Constants and callback patterns\n    ‚îú‚îÄ‚îÄ decorators.py     # @admin_only decorator\n    ‚îî‚îÄ‚îÄ helpers.py        # Auto-deletion scheduler\n```\n\n### Key Features\n1. **Content Management**: Browse and search movies/series by name, year, or category\n2. **Free Access**: All users can watch and download content for free\n3. **Admin Panel**: Add/delete/rename content, manage series seasons and episodes\n4. **Force Join**: Users must join a specified Telegram channel to access the bot\n5. **Auto-Deletion**: Content files auto-delete after a configurable timer (copyright protection)\n6. **Deep Linking**: Direct access to specific content via shareable links\n\n### Configuration\nThe bot uses the following configuration (in `config.py`):\n- `BOT_TOKEN`: Telegram bot token from @BotFather (stored in environment variable)\n- `ADMIN_IDS`: List of admin user IDs\n- `FORCE_JOIN_CHANNEL`: Channel users must join (e.g., \"@TGBOTS_CODE\")\n\n### Workflow\n- **Bot**: Runs `python bot.py` as a console application (Telegram bot polling)\n\n## Environment Variables\n- `BOT_TOKEN`: Your Telegram bot token (get from @BotFather)\n\n## Dependencies\n- python-telegram-bot[ext] - Telegram bot framework\n- Additional dependencies: httpx, aiolimiter, apscheduler, cachetools, tornado\n\n## User Preferences\n- No specific user preferences documented yet\n\n## Notes\n- The bot uses JSON files for data storage (not a traditional database)\n- All content is freely accessible to users who join the required channel\n- Content can have auto-delete timers to handle copyright issues\n- The bot requires admin privileges in the force join channel to function properly\n","size_bytes":4276},"database/db_handler.py":{"content":"# database/db_handler.py\n\nimport json\nimport os\nfrom typing import List, Dict, Any, Optional\nimport uuid # Import uuid\n\n# Define file paths\nDB_DIR = os.path.dirname(__file__)\nMOVIES_DB_PATH = os.path.join(DB_DIR, \"movies_db.json\")\nSERIES_DB_PATH = os.path.join(DB_DIR, \"series_db.json\")\n\n# Ensure database files exist\ndef initialize_databases():\n    if not os.path.exists(MOVIES_DB_PATH):\n        with open(MOVIES_DB_PATH, 'w') as f:\n            json.dump([], f)\n    if not os.path.exists(SERIES_DB_PATH):\n        with open(SERIES_DB_PATH, 'w') as f:\n            json.dump([], f)\n\ndef load_data(db_path: str) -> List[Dict[str, Any]]:\n    \"\"\"Loads data from a JSON file.\"\"\"\n    try:\n        with open(db_path, 'r', encoding='utf-8') as f:\n            return json.load(f)\n    except (FileNotFoundError, json.JSONDecodeError):\n        return []\n\ndef save_data(db_path: str, data: List[Dict[str, Any]]):\n    \"\"\"Saves data to a JSON file.\"\"\"\n    with open(db_path, 'w', encoding='utf-8') as f:\n        json.dump(data, f, indent=4)\n\n# --- Movie Functions ---\ndef get_all_movies() -> List[Dict[str, Any]]:\n    return load_data(MOVIES_DB_PATH)\n\ndef add_movie(movie_data: Dict[str, Any]):\n    movies = get_all_movies()\n    # Ensure ID is always set for new items\n    if \"id\" not in movie_data:\n        movie_data[\"id\"] = str(uuid.uuid4())\n    movies.append(movie_data)\n    save_data(MOVIES_DB_PATH, movies)\n\ndef find_movie_by_id(movie_id: str) -> Optional[Dict[str, Any]]:\n    return next((m for m in get_all_movies() if m.get(\"id\") == movie_id), None)\n\ndef update_movie(movie_id: str, new_data: Dict[str, Any]) -> bool:\n    movies = get_all_movies()\n    for i, movie in enumerate(movies):\n        if movie.get(\"id\") == movie_id:\n            movies[i].update(new_data)\n            save_data(MOVIES_DB_PATH, movies)\n            return True\n    return False\n\ndef delete_movie_by_id(movie_id: str) -> bool:\n    movies = get_all_movies()\n    initial_len = len(movies)\n    movies = [m for m in movies if m.get(\"id\") != movie_id]\n    if len(movies) < initial_len:\n        save_data(MOVIES_DB_PATH, movies)\n        return True\n    return False\n\n# --- Series Functions ---\ndef get_all_series() -> List[Dict[str, Any]]:\n    return load_data(SERIES_DB_PATH)\n\ndef add_series(series_data: Dict[str, Any]):\n    series = get_all_series()\n    # Ensure ID is always set for new items\n    if \"id\" not in series_data:\n        series_data[\"id\"] = str(uuid.uuid4())\n    series.append(series_data)\n    save_data(SERIES_DB_PATH, series)\n    \ndef find_series_by_id(series_id: str) -> Optional[Dict[str, Any]]:\n    return next((s for s in get_all_series() if s.get(\"id\") == series_id), None)\n\ndef update_series(series_id: str, new_data: Dict[str, Any]) -> bool:\n    all_series = get_all_series()\n    for i, series in enumerate(all_series):\n        if series.get(\"id\") == series_id:\n            all_series[i].update(new_data)\n            save_data(SERIES_DB_PATH, all_series)\n            return True\n    return False\n\ndef delete_series_by_id(series_id: str) -> bool:\n    all_series = get_all_series()\n    initial_len = len(all_series)\n    all_series = [s for s in all_series if s.get(\"id\") != series_id]\n    if len(all_series) < initial_len:\n        save_data(SERIES_DB_PATH, all_series)\n        return True\n    return False\n\n# --- Utility Functions ---\ndef get_all_unique_years() -> List[int]:\n    movies, series = get_all_movies(), get_all_series()\n    years = set()\n    for item in movies + series:\n        year = item.get('year')\n        if isinstance(year, int):\n            years.add(year)\n    return sorted(list(years), reverse=True)\n\ndef get_all_unique_categories() -> List[str]:\n    \"\"\"Get all unique categories from both movies and series, sorted alphabetically.\"\"\"\n    movies, series = get_all_movies(), get_all_series()\n    categories = set()\n    for item in movies + series:\n        if 'categories' in item and isinstance(item['categories'], list):\n            for category in item['categories']:\n                categories.add(category.strip())\n    return sorted(list(categories))\n\n# Initialize on import\ninitialize_databases()","size_bytes":4107},"handlers/user/browsing.py":{"content":"# handlers/user/browsing.py\nimport logging\nimport asyncio\nfrom telegram import Update\nfrom telegram.error import BadRequest\nfrom telegram.ext import ContextTypes, CallbackQueryHandler\nfrom telegram.constants import ParseMode\nfrom telegram.helpers import escape_markdown\n\nfrom database import db_handler\nfrom keyboards import inline as keyboards\nfrom utils import constants as const\nfrom utils.helpers import schedule_content_deletion\n\nlogger = logging.getLogger(__name__)\n\n# --- CORE LOGIC: Helper functions for sending files ---\n\n# These helpers are called by the decorated handlers, so they don't need the decorator themselves.\nasync def _send_movie_files(context: ContextTypes.DEFAULT_TYPE, chat_id: int, movie: dict, photo_message_id: int):\n    video_tasks = [\n        context.bot.send_video(chat_id=chat_id, video=video_id, caption=f\"üé¨ {movie['name']}\")\n        for video_id in movie['videos']\n    ]\n    video_message_ids = []\n    try:\n        sent_messages = await asyncio.gather(*video_tasks)\n        video_message_ids = [msg.message_id for msg in sent_messages]\n    except Exception as e:\n        logger.error(f\"Failed to send a video for movie {movie['id']}: {e}\")\n        await context.bot.send_message(chat_id=chat_id, text=\"‚ö†Ô∏è An error occurred while sending a video file.\")\n\n    if video_message_ids or photo_message_id:\n        schedule_content_deletion(\n            context, chat_id, video_message_ids, photo_message_id, movie['timer'],\n            'movie', movie['id'], movie['name']\n        )\n        if movie['timer'] > 0:\n            await asyncio.sleep(1)\n            await context.bot.send_message(\n                chat_id=chat_id, text=const.DELETION_WARNING_TEXT.format(timer=movie['timer']),\n                parse_mode=ParseMode.MARKDOWN\n            )\n    \n    if const.THANK_YOU_STICKER_ID:\n        await asyncio.sleep(0.5)\n        try:\n            await context.bot.send_sticker(chat_id=chat_id, sticker=const.THANK_YOU_STICKER_ID)\n        except BadRequest as e:\n            logger.error(f\"Failed to send sticker. ID might be invalid: {e}\")\n\nasync def _send_series_season_files(context: ContextTypes.DEFAULT_TYPE, chat_id: int, series: dict, season_num: str, photo_message_id: int):\n    episodes = series['seasons'][season_num]\n    video_message_ids = []\n\n    for idx, episode_id in enumerate(episodes, 1):\n        try:\n            caption = f\"üì∫ {series['name']} - S{season_num}E{idx}\"\n            sent_message = await context.bot.send_video(chat_id=chat_id, video=episode_id, caption=caption)\n            video_message_ids.append(sent_message.message_id)\n            await asyncio.sleep(0.5)\n        except Exception as e:\n            logger.error(f\"Failed to send episode S{season_num}E{idx} for series {series['id']}: {e}\")\n            await context.bot.send_message(chat_id=chat_id, text=f\"‚ö†Ô∏è An error occurred while sending episode S{season_num}E{idx}.\")\n\n    if video_message_ids or photo_message_id:\n        schedule_content_deletion(\n            context, chat_id, video_message_ids, photo_message_id, series['timer'],\n            'series', series['id'], f\"{series['name']} S{season_num}\"\n        )\n        if series['timer'] > 0:\n            await asyncio.sleep(1)\n            await context.bot.send_message(\n                chat_id=chat_id, text=const.DELETION_WARNING_TEXT.format(timer=series['timer']),\n                parse_mode=ParseMode.MARKDOWN\n            )\n    \n    if const.THANK_YOU_STICKER_ID:\n        await asyncio.sleep(0.5)\n        try:\n            await context.bot.send_sticker(chat_id=chat_id, sticker=const.THANK_YOU_STICKER_ID)\n        except BadRequest as e:\n            logger.error(f\"Failed to send sticker. ID might be invalid: {e}\")\n\n# --- HANDLERS (Triggered by Reply Keyboard or Commands) ---\n\nasync def show_all_movies(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    movies = db_handler.get_all_movies()\n    if not movies: await update.message.reply_text(\"‚ÑπÔ∏è No movies have been added yet.\"); return\n    await update.message.reply_text(\"Displaying movies (Page 1):\", reply_markup=keyboards.movie_list_keyboard(movies, page=0))\n\nasync def show_all_series(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    series = db_handler.get_all_series()\n    if not series: await update.message.reply_text(\"‚ÑπÔ∏è No series have been added yet.\"); return\n    await update.message.reply_text(\"Displaying series (Page 1):\", reply_markup=keyboards.series_list_keyboard(series, page=0))\n\nasync def show_browse_by_year(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    await update.message.reply_text(\"Select a year to browse:\", reply_markup=keyboards.year_selection_keyboard())\n\nasync def show_browse_by_category(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    \"\"\"Sends the first page of the category selection menu.\"\"\"\n    await update.message.reply_text(\"Select a category to browse:\", reply_markup=keyboards.category_selection_keyboard(page=0))\n\n# --- CALLBACK HANDLERS (Triggered by Inline Buttons) ---\n\n# These handlers are usually for navigation or fetching *lists*, not directly accessing content files.\n# So, they don't *strictly* need premium_only, as the content selection handlers below will catch it.\n# However, if you want the premium check to happen earlier (before showing lists), you can add it.\n# For now, I'll keep it on the actual content-delivery steps.\n\nasync def handle_back_to_main(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    query = update.callback_query\n    await query.answer()\n    try: await query.edit_message_text(\"‚úÖ Selection cancelled. Use the menu below.\")\n    except BadRequest as e:\n        if \"Message is not modified\" not in str(e): logger.warning(f\"Error handling back button: {e}\")\n\nasync def back_to_year_selection(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    query = update.callback_query\n    await query.answer()\n    await query.edit_message_text(\"Select a year to browse:\", reply_markup=keyboards.year_selection_keyboard())\n\nasync def movie_page_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    query = update.callback_query\n    await query.answer()\n    page = int(query.data.replace(const.CALLBACK_MOVIE_PAGE, \"\"))\n    movies = db_handler.get_all_movies()\n    await query.edit_message_text(f\"Displaying movies (Page {page+1}):\", reply_markup=keyboards.movie_list_keyboard(movies, page=page))\n\nasync def series_page_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    query = update.callback_query\n    await query.answer()\n    page = int(query.data.replace(const.CALLBACK_SERIES_PAGE, \"\"))\n    series = db_handler.get_all_series()\n    await query.edit_message_text(f\"Displaying series (Page {page+1}):\", reply_markup=keyboards.series_list_keyboard(series, page=page))\n\nasync def year_page_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    query = update.callback_query\n    await query.answer()\n    page = int(query.data.split('_')[-1])\n    try: await query.edit_message_reply_markup(reply_markup=keyboards.year_selection_keyboard(page=page))\n    except BadRequest as e:\n        if \"Message is not modified\" not in str(e): logger.warning(f\"Error on year page handler: {e}\")\n\nasync def year_select_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    query = update.callback_query\n    await query.answer()\n    year = int(query.data.split('_')[-1])\n    try: await query.edit_message_text(f\"What would you like to see from {year}?\", reply_markup=keyboards.year_content_type_keyboard(year))\n    except BadRequest as e:\n        if \"Message is not modified\" not in str(e): logger.warning(f\"Error on year select handler: {e}\")\n\nasync def year_content_type_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    query = update.callback_query\n    await query.answer()\n    parts = query.data.split('_')\n    year, content_type = int(parts[-2]), parts[-1]\n    try:\n        if content_type == \"movies\":\n            content = [m for m in db_handler.get_all_movies() if m.get('year') == year]\n            if not content: await query.edit_message_text(f\"No movies found for {year}.\", reply_markup=keyboards.year_content_type_keyboard(year)); return\n            await query.edit_message_text(f\"Movies from {year}:\", reply_markup=keyboards.movie_list_keyboard(content))\n        else:\n            content = [s for s in db_handler.get_all_series() if s.get('year') == year]\n            if not content: await query.edit_message_text(f\"No series found for {year}.\", reply_markup=keyboards.year_content_type_keyboard(year)); return\n            await query.edit_message_text(f\"Series from {year}:\", reply_markup=keyboards.series_list_keyboard(content))\n    except BadRequest as e:\n        if \"Message is not modified\" not in str(e): logger.warning(f\"Error on year content type handler: {e}\")\n\nasync def category_page_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    query = update.callback_query\n    await query.answer()\n    page = int(query.data.replace(const.CALLBACK_CATEGORY_PAGE, \"\"))\n    await query.edit_message_reply_markup(reply_markup=keyboards.category_selection_keyboard(page=page))\n\nasync def category_select_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    query = update.callback_query\n    await query.answer()\n    category = query.data.replace(const.CALLBACK_CATEGORY_SELECT, \"\")\n    await query.edit_message_text(f\"What would you like to see from the '{category}' category?\", reply_markup=keyboards.category_content_type_keyboard(category))\n\nasync def category_content_type_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    query = update.callback_query\n    await query.answer()\n    parts = query.data.replace(const.CALLBACK_CATEGORY_CONTENT_TYPE, \"\").split('_')\n    category, content_type = parts[0], parts[1]\n    \n    if content_type == \"movies\":\n        content = [m for m in db_handler.get_all_movies() if category in m.get('categories', [])]\n        if not content:\n            await query.edit_message_text(f\"No movies found in the '{category}' category.\", reply_markup=keyboards.category_content_type_keyboard(category)); return\n        await query.edit_message_text(f\"Movies in '{category}':\", reply_markup=keyboards.movie_list_keyboard(content))\n    else: # series\n        content = [s for s in db_handler.get_all_series() if category in s.get('categories', [])]\n        if not content:\n            await query.edit_message_text(f\"No series found in the '{category}' category.\", reply_markup=keyboards.category_content_type_keyboard(category)); return\n        await query.edit_message_text(f\"Series in '{category}':\", reply_markup=keyboards.series_list_keyboard(content))\n\nasync def movie_select_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    query = update.callback_query\n    await query.answer()\n    movie_id = query.data.replace(const.CALLBACK_MOVIE_SELECT, \"\")\n    movie = db_handler.find_movie_by_id(movie_id)\n    if not movie: await query.edit_message_text(\"‚ùå Movie not found.\"); return\n    await query.delete_message()\n    safe_name = escape_markdown(movie['name'], version=2)\n    caption = rf\"üé¨ *{safe_name}* `({movie['year']})`\"\n    photo_message = await query.message.reply_photo(photo=movie['cover_photo'], caption=caption, parse_mode=ParseMode.MARKDOWN_V2)\n    await _send_movie_files(context, query.message.chat_id, movie, photo_message.message_id)\n\nasync def series_select_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    query = update.callback_query\n    await query.answer()\n    series_id = query.data.replace(const.CALLBACK_SERIES_SELECT, \"\")\n    series = db_handler.find_series_by_id(series_id)\n    if not series: await query.edit_message_text(\"‚ùå Series not found.\"); return\n    await query.delete_message()\n    \n    # Apply MarkdownV2 escaping for the caption\n    safe_name = escape_markdown(series['name'], version=2)\n    safe_year = escape_markdown(str(series['year']), version=2)\n    caption = rf\"üì∫ *{safe_name}* `\\({safe_year}\\)`\\n\\nSelect a season:\" # Escaped parentheses for year\n\n    photo_message_with_seasons = await query.message.reply_photo(photo=series['cover_photo'], caption=caption, parse_mode=ParseMode.MARKDOWN_V2, reply_markup=keyboards.series_season_keyboard(series))\n    context.user_data[f\"photo_msg_{series_id}\"] = photo_message_with_seasons.message_id\n\nasync def season_select_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    query = update.callback_query\n    await query.answer()\n    data_parts = query.data.replace(const.CALLBACK_SEASON_SELECT, \"\").split('_')\n    series_id, season_num = data_parts[0], data_parts[1]\n    series = db_handler.find_series_by_id(series_id)\n    if not series or season_num not in series['seasons']: await query.edit_message_text(\"‚ùå Season not found.\"); return\n    photo_message_id = context.user_data.get(f\"photo_msg_{series_id}\")\n    await query.edit_message_reply_markup(reply_markup=None)\n    \n    # Apply MarkdownV2 escaping for the text message\n    safe_name = escape_markdown(series['name'], version=2)\n    safe_season_num = escape_markdown(season_num, version=2)\n    text = rf\"Sending all episodes for *{safe_name} \\- Season {safe_season_num}*\\.\\.\\.\" # Escaped period\n\n    await query.message.reply_text(text, parse_mode=ParseMode.MARKDOWN_V2)\n    await _send_series_season_files(context, query.message.chat_id, series, season_num, photo_message_id)\n\nasync def reget_movie_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    query = update.callback_query\n    await query.answer()\n    movie_id = query.data.replace(const.CALLBACK_REGET_MOVIE, \"\")\n    movie = db_handler.find_movie_by_id(movie_id)\n    if not movie: await query.edit_message_text(\"‚ùå This movie seems to have been removed.\"); return\n    safe_name = escape_markdown(movie['name'], version=2)\n    text = rf\"Re\\-sending files for *{safe_name}*\\.\\.\\.\"\n    await query.edit_message_text(text, parse_mode=ParseMode.MARKDOWN_V2)\n    caption = rf\"üé¨ *{safe_name}* `({movie['year']})`\"\n    photo_message = await query.message.reply_photo(photo=movie['cover_photo'], caption=caption, parse_mode=ParseMode.MARKDOWN_V2)\n    await _send_movie_files(context, query.message.chat_id, movie, photo_message.message_id)\n\nasync def reget_series_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    query = update.callback_query\n    await query.answer()\n    series_id = query.data.replace(const.CALLBACK_REGET_SERIES, \"\")\n    series = db_handler.find_series_by_id(series_id)\n    if not series: await query.edit_message_text(\"‚ùå This series seems to have been removed.\"); return\n    \n    # Apply MarkdownV2 escaping for the text message\n    safe_name = escape_markdown(series['name'], version=2)\n    safe_year = escape_markdown(str(series['year']), version=2)\n    text = rf\"üì∫ *{safe_name}* `\\({safe_year}\\)`\\n\\nWhich season would you like to get again\\?\" # Escaped parentheses and question mark\n\n    await query.edit_message_text(text, parse_mode=ParseMode.MARKDOWN_V2, reply_markup=keyboards.series_season_keyboard(series))\n\nbrowsing_handlers = [\n    CallbackQueryHandler(handle_back_to_main, pattern=\"^back_to_main_menu$\"),\n    CallbackQueryHandler(back_to_year_selection, pattern=\"^browse_year_from_callback$\"),\n    CallbackQueryHandler(show_browse_by_category, pattern=\"^browse_category_from_callback$\"),\n    CallbackQueryHandler(movie_page_handler, pattern=f\"^{const.CALLBACK_MOVIE_PAGE}\"),\n    CallbackQueryHandler(series_page_handler, pattern=f\"^{const.CALLBACK_SERIES_PAGE}\"),\n    CallbackQueryHandler(year_page_handler, pattern=f\"^{const.CALLBACK_YEAR_PAGE}\"),\n    CallbackQueryHandler(category_page_handler, pattern=f\"^{const.CALLBACK_CATEGORY_PAGE}\"),\n    CallbackQueryHandler(year_select_handler, pattern=f\"^{const.CALLBACK_YEAR_SELECT}\"),\n    CallbackQueryHandler(category_select_handler, pattern=f\"^{const.CALLBACK_CATEGORY_SELECT}\"),\n    CallbackQueryHandler(year_content_type_handler, pattern=f\"^{const.CALLBACK_YEAR_CONTENT_TYPE}\"),\n    CallbackQueryHandler(category_content_type_handler, pattern=f\"^{const.CALLBACK_CATEGORY_CONTENT_TYPE}\"),\n    CallbackQueryHandler(movie_select_handler, pattern=f\"^{const.CALLBACK_MOVIE_SELECT}\"),\n    CallbackQueryHandler(series_select_handler, pattern=f\"^{const.CALLBACK_SERIES_SELECT}\"),\n    CallbackQueryHandler(season_select_handler, pattern=f\"^{const.CALLBACK_SEASON_SELECT}\"),\n    CallbackQueryHandler(reget_movie_handler, pattern=f\"^{const.CALLBACK_REGET_MOVIE}\"),\n    CallbackQueryHandler(reget_series_handler, pattern=f\"^{const.CALLBACK_REGET_SERIES}\"),\n]","size_bytes":16511},"config.py":{"content":"# config.py\n\nimport os\n\n# --- REQUIRED ---\n# Get your bot token from @BotFather on Telegram\nBOT_TOKEN = os.getenv(\"BOT_TOKEN\")\n\n# --- REQUIRED ---\n# Get your numeric Telegram user ID, e.g., from @userinfobot\n# You can add multiple admin IDs, separated by commas\nADMIN_IDS = [6158106622, 1661108890] \n\n# --- OPTIONAL: FORCE JOIN FEATURE ---\n# Add your channel's username (e.g., \"@mychannelname\"). \n# The bot MUST be an admin in this channel.\n# If you don't want this feature, set it to None.\n# Example: FORCE_JOIN_CHANNEL = \"@your_channel_username\"\nFORCE_JOIN_CHANNEL = \"@TheWayOfficial\"\n\n","size_bytes":588},"keyboards/__init__.py":{"content":"","size_bytes":0},"bot.py":{"content":"# bot.py (main.py)\n\nimport logging\nfrom telegram import Update\nfrom telegram.ext import (\n    Application, MessageHandler, filters,\n    CallbackQueryHandler, PicklePersistence, ContextTypes, CommandHandler,\n    TypeHandler, ApplicationHandlerStop, JobQueue\n)\nfrom telegram.error import TelegramError\nimport config\n\nfrom keyboards.reply import main_reply_keyboard\nfrom handlers.user.start import start, start_handler, help_handler, help_command\nfrom handlers.user.search import movie_search_handler, series_search_handler, generic_search_handler\nfrom handlers.user.browsing import browsing_handlers, show_all_movies, show_all_series, show_browse_by_year, show_browse_by_category # Ensure browsing_handlers is explicitly imported\nfrom handlers.admin.admin_panel import admin_conversation_handler\nfrom middleware import force_join_middleware\n\nlogging.basicConfig(\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\",\n    level=logging.INFO,\n)\nlogger = logging.getLogger(__name__)\n\n# This function should be in main.py as it needs access to other handlers\nasync def check_join_status_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    query = update.callback_query\n    await query.answer(\"Checking your membership status...\", show_alert=False)\n    \n    # After the middleware confirms membership, this will run.\n    await query.message.delete()\n    # Call the start handler to show the welcome message\n    await start(update, context)\n\n# --- MOVE global_middleware FUNCTION DEFINITION HERE ---\n# It must be defined before main() uses it.\nasync def global_middleware(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    is_allowed = await force_join_middleware(update, context)\n    if not is_allowed:\n        raise ApplicationHandlerStop\n\nasync def diagnose(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    user_id = update.effective_user.id\n    if user_id not in config.ADMIN_IDS: return\n    if not config.FORCE_JOIN_CHANNEL: await update.message.reply_text(\"Diag: FORCE_JOIN_CHANNEL not set.\"); return\n    await update.message.reply_text(f\"Running diagnostic for channel: {config.FORCE_JOIN_CHANNEL}\\nChecking user ID: {user_id}\")\n    try:\n        member = await context.bot.get_chat_member(chat_id=config.FORCE_JOIN_CHANNEL, user_id=user_id)\n        await update.message.reply_text(f\"‚úÖ SUCCESS!\\nAPI status: '{member.status}'\\nThis means bot permissions are correct.\")\n    except Exception as e:\n        await update.message.reply_text(f\"‚ùå FAILED!\\nAPI error: `{e}`\\n\\nCheck if bot is admin or if channel username is correct.\", parse_mode='Markdown')\n\ndef main():\n    logger.info(\"Starting bot...\")\n    persistence = PicklePersistence(filepath=\"bot_persistence.pickle\")\n    \n    # --- Initialize JobQueue ---\n    job_queue = JobQueue()\n    \n    application = Application.builder().token(config.BOT_TOKEN).persistence(persistence).job_queue(job_queue).build()\n    \n    # --- MIDDLEWARE SETUP ---\n    application.add_handler(TypeHandler(Update, global_middleware), group=-1)\n\n    # --- Other Handlers ---\n    application.add_handler(CommandHandler(\"diag\", diagnose))\n    application.add_handler(admin_conversation_handler)\n    application.add_handler(start_handler)\n    application.add_handler(help_handler)\n    application.add_handler(movie_search_handler)\n    application.add_handler(series_search_handler)\n    \n    # Correctly add a list of browsing handlers\n    application.add_handlers(browsing_handlers) # This is the correct way to add a list of handlers\n\n    application.add_handler(CallbackQueryHandler(check_join_status_callback, pattern=\"^check_join_status$\"))\n    \n    # Handlers for Reply Keyboard\n    application.add_handler(MessageHandler(filters.Regex(\"^üé¨ All Movies$\"), show_all_movies))\n    application.add_handler(MessageHandler(filters.Regex(\"^üì∫ All Series$\"), show_all_series))\n    application.add_handler(MessageHandler(filters.Regex(\"^üóì Browse by Year$\"), show_browse_by_year))\n    application.add_handler(MessageHandler(filters.Regex(\"^üìö Browse by Category$\"), show_browse_by_category))\n    application.add_handler(MessageHandler(filters.Regex(\"^‚ùì Help & FAQ$\"), help_command))\n    \n    application.add_handler(generic_search_handler)\n    \n    logger.info(\"Bot is running. Press Ctrl-C to stop.\")\n    application.run_polling()\n    \nif __name__ == \"__main__\":\n    main()","size_bytes":4348},"utils/helpers.py":{"content":"# utils/helpers.py\nimport logging\nfrom telegram.ext import ContextTypes\nfrom telegram.error import Forbidden, BadRequest\nfrom keyboards.inline import get_file_again_keyboard\nfrom typing import List, Optional\n\nlogger = logging.getLogger(__name__)\n\nasync def delete_and_prompt_callback(context: ContextTypes.DEFAULT_TYPE):\n    \"\"\"\n    Job callback. Deletes video messages, the photo message, and sends a \"Get Again\" prompt.\n    \"\"\"\n    job = context.job\n    chat_id = job.chat_id\n    video_message_ids = job.data.get('video_message_ids', [])\n    photo_message_id = job.data.get('photo_message_id') # Get the photo ID\n    content_type = job.data['content_type']\n    content_id = job.data['content_id']\n    content_name = job.data['content_name']\n\n    # --- Combine all message IDs to delete ---\n    all_message_ids = []\n    if photo_message_id:\n        all_message_ids.append(photo_message_id)\n    all_message_ids.extend(video_message_ids)\n    \n    deleted_count = 0\n    for message_id in all_message_ids:\n        try:\n            await context.bot.delete_message(chat_id=chat_id, message_id=message_id)\n            deleted_count += 1\n        except BadRequest as e:\n            # It's common for a user to have already deleted the message.\n            if \"message to delete not found\" in str(e).lower():\n                pass\n            else:\n                logger.warning(f\"Could not delete message {message_id} in chat {chat_id}: {e}\")\n        except Exception as e:\n            logger.warning(f\"Unexpected error deleting message {message_id} in chat {chat_id}: {e}\")\n\n    logger.info(f\"Successfully deleted {deleted_count}/{len(all_message_ids)} messages for content '{content_name}'.\")\n\n    # --- Send the \"Get File Again\" prompt ---\n    if deleted_count > 0 or len(all_message_ids) > 0: # Send prompt even if user deleted first\n        try:\n            prompt_text = (\n                f\"‚úÖ **'{content_name}'** ·Åè ·Äñ·Ä≠·ÄØ·ÄÑ·Ä∫·Äô·Äª·Ä¨·Ä∏·ÄÄ·Ä≠·ÄØ ·Ä°·Ä±·Ä¨·ÄÑ·Ä∫·Äô·Äº·ÄÑ·Ä∫·ÄÖ·ÄΩ·Ä¨·Äñ·Äª·ÄÄ·Ä∫·Äï·Äº·ÄÆ·Ä∏·Äï·Ä´·Äï·Äº·ÄÆ·Åã\\n\\n\"\n                \"·Äñ·Ä≠·ÄØ·ÄÑ·Ä∫·ÄÄ·Ä≠·ÄØ ·Äï·Äº·Äî·Ä∫·Äú·Ää·Ä∫·Äõ·Äö·Ä∞·Äõ·Äî·Ä∫ ·Ä°·Ä±·Ä¨·ÄÄ·Ä∫·Äï·Ä´·ÄÅ·Äú·ÄØ·Äê·Ä∫·ÄÄ·Ä≠·ÄØ·Äî·Äæ·Ä≠·Äï·Ä∫·Äï·Ä´·Åã\\n\\n\"\n                f\"‚úÖ The files for **'{content_name}'** have been deleted.\\n\\n\"\n                \"Click the button below to get them again.\"\n            )\n            await context.bot.send_message(\n                chat_id=chat_id,\n                text=prompt_text,\n                reply_markup=get_file_again_keyboard(content_type, content_id),\n                parse_mode='Markdown'\n            )\n        except Forbidden:\n             logger.warning(f\"Bot blocked by user {chat_id}, cannot send 'Get Again' prompt.\")\n        except Exception as e:\n            logger.error(f\"Failed to send 'Get Again' prompt to {chat_id}: {e}\")\n\ndef schedule_content_deletion(\n    context: ContextTypes.DEFAULT_TYPE, \n    chat_id: int, \n    video_message_ids: List[int],\n    photo_message_id: Optional[int],\n    delay_minutes: int,\n    content_type: str,\n    content_id: str,\n    content_name: str\n):\n    \"\"\"\n    Schedules a single job to delete a batch of messages (videos + photo) and then send a prompt.\n    \"\"\"\n    if delay_minutes > 0 and (video_message_ids or photo_message_id):\n        delay_seconds = delay_minutes * 60\n        context.job_queue.run_once(\n            delete_and_prompt_callback,\n            when=delay_seconds,\n            data={\n                'video_message_ids': video_message_ids,\n                'photo_message_id': photo_message_id, # Pass the photo ID to the job\n                'content_type': content_type,\n                'content_id': content_id,\n                'content_name': content_name\n            },\n            chat_id=chat_id,\n            name=f\"delete_prompt_{chat_id}_{content_id}\"\n        )\n        total_messages = len(video_message_ids) + (1 if photo_message_id else 0)\n        logger.info(f\"Scheduled deletion for {total_messages} messages for content '{content_name}' in {delay_minutes} minutes.\")","size_bytes":4034},"handlers/admin/__init__.py":{"content":"","size_bytes":0}},"version":2}